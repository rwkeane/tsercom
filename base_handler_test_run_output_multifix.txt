============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-8.3.5, pluggy-1.5.0
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, timeout-2.4.0, mock-3.14.1, anyio-4.9.0, cov-6.1.1, json-report-1.5.0, metadata-3.1.1
asyncio: mode=strict, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
timeout: 60.0s
timeout method: signal
timeout func_only: False
collected 21 items

tsercom/runtime/runtime_data_handler_base_unittest.py .......EEEEEFF.... [ 85%]
...                                                                      [100%]

==================================== ERRORS ====================================
_ ERROR at setup of TestRuntimeDataHandlerBaseBehavior.test_processor_desynchronize _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f3719ba71f0>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f371997bee0>
test_caller_id_instance = CallerIdentifier('e382bfd8-de88-4360-b081-d808637ca842')
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='139874629465184'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f37199716f0>

    @pytest.fixture
    def data_processor(
        self,
        handler,
        test_caller_id_instance,
        mock_sync_clock,
        mocker,  # Added mocker
    ):
        # Create an instance of the inner class for testing
        # The _create_data_processor method is part of RuntimeDataHandlerBase
        # Ensure the mock_id_tracker (which is handler._RuntimeDataHandlerBase__id_tracker)
        # is set up to return a poller when .get(caller_id) is called.
        mock_poller_for_dp = mocker.MagicMock(spec=AsyncPoller)
>       handler._RuntimeDataHandlerBase__id_tracker.get.return_value = (
            "dummy_ip",
            1234,
            mock_poller_for_dp,
        )
E       AttributeError: 'method' object has no attribute 'return_value'

tsercom/runtime/runtime_data_handler_base_unittest.py:212: AttributeError
_ ERROR at setup of TestRuntimeDataHandlerBaseBehavior.test_processor_deregister_caller _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f3719ba75b0>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f37199e3220>
test_caller_id_instance = CallerIdentifier('5393c2d7-b073-407a-af8b-3e498096b07b')
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='139874629868448'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f37199a7be0>

    @pytest.fixture
    def data_processor(
        self,
        handler,
        test_caller_id_instance,
        mock_sync_clock,
        mocker,  # Added mocker
    ):
        # Create an instance of the inner class for testing
        # The _create_data_processor method is part of RuntimeDataHandlerBase
        # Ensure the mock_id_tracker (which is handler._RuntimeDataHandlerBase__id_tracker)
        # is set up to return a poller when .get(caller_id) is called.
        mock_poller_for_dp = mocker.MagicMock(spec=AsyncPoller)
>       handler._RuntimeDataHandlerBase__id_tracker.get.return_value = (
            "dummy_ip",
            1234,
            mock_poller_for_dp,
        )
E       AttributeError: 'method' object has no attribute 'return_value'

tsercom/runtime/runtime_data_handler_base_unittest.py:212: AttributeError
_ ERROR at setup of TestRuntimeDataHandlerBaseBehavior.test_processor_process_data_with_datetime _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f3719ba7a60>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f37199df760>
test_caller_id_instance = CallerIdentifier('3760a5f1-2a58-4ccc-9717-3ed1d5589ced')
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='139874629744720'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f37199df610>

    @pytest.fixture
    def data_processor(
        self,
        handler,
        test_caller_id_instance,
        mock_sync_clock,
        mocker,  # Added mocker
    ):
        # Create an instance of the inner class for testing
        # The _create_data_processor method is part of RuntimeDataHandlerBase
        # Ensure the mock_id_tracker (which is handler._RuntimeDataHandlerBase__id_tracker)
        # is set up to return a poller when .get(caller_id) is called.
        mock_poller_for_dp = mocker.MagicMock(spec=AsyncPoller)
>       handler._RuntimeDataHandlerBase__id_tracker.get.return_value = (
            "dummy_ip",
            1234,
            mock_poller_for_dp,
        )
E       AttributeError: 'method' object has no attribute 'return_value'

tsercom/runtime/runtime_data_handler_base_unittest.py:212: AttributeError
_ ERROR at setup of TestRuntimeDataHandlerBaseBehavior.test_processor_process_data_with_server_timestamp _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f3719ba7dc0>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f37199ffd30>
test_caller_id_instance = CallerIdentifier('689fff92-48c7-4260-9507-48d63286505d')
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='139874629804304'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f37199ffdf0>

    @pytest.fixture
    def data_processor(
        self,
        handler,
        test_caller_id_instance,
        mock_sync_clock,
        mocker,  # Added mocker
    ):
        # Create an instance of the inner class for testing
        # The _create_data_processor method is part of RuntimeDataHandlerBase
        # Ensure the mock_id_tracker (which is handler._RuntimeDataHandlerBase__id_tracker)
        # is set up to return a poller when .get(caller_id) is called.
        mock_poller_for_dp = mocker.MagicMock(spec=AsyncPoller)
>       handler._RuntimeDataHandlerBase__id_tracker.get.return_value = (
            "dummy_ip",
            1234,
            mock_poller_for_dp,
        )
E       AttributeError: 'method' object has no attribute 'return_value'

tsercom/runtime/runtime_data_handler_base_unittest.py:212: AttributeError
_ ERROR at setup of TestRuntimeDataHandlerBaseBehavior.test_processor_process_data_no_timestamp _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f3719ba7520>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f3719a47df0>
test_caller_id_instance = CallerIdentifier('55db9bad-16c6-4c82-8420-1f452fd98609')
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='139874628438864'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f3719a47e20>

    @pytest.fixture
    def data_processor(
        self,
        handler,
        test_caller_id_instance,
        mock_sync_clock,
        mocker,  # Added mocker
    ):
        # Create an instance of the inner class for testing
        # The _create_data_processor method is part of RuntimeDataHandlerBase
        # Ensure the mock_id_tracker (which is handler._RuntimeDataHandlerBase__id_tracker)
        # is set up to return a poller when .get(caller_id) is called.
        mock_poller_for_dp = mocker.MagicMock(spec=AsyncPoller)
>       handler._RuntimeDataHandlerBase__id_tracker.get.return_value = (
            "dummy_ip",
            1234,
            mock_poller_for_dp,
        )
E       AttributeError: 'method' object has no attribute 'return_value'

tsercom/runtime/runtime_data_handler_base_unittest.py:212: AttributeError
=================================== FAILURES ===================================
_ TestRuntimeDataHandlerBaseRegisterCaller.test_register_caller_with_endpoint_port_success _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseRegisterCaller object at 0x7f3719ba7af0>
handler_fixture = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f3719a46050>
mock_endpoint_processor_fixture = <MagicMock name='mock()' spec='EndpointDataProcessor' id='139874629807040'>

    @pytest.mark.asyncio
    async def test_register_caller_with_endpoint_port_success(
        self, handler_fixture, mock_endpoint_processor_fixture
    ):
        caller_id = CallerIdentifier.random()
        endpoint = "127.0.0.1"
        port = 8080
        handler_fixture._register_caller_mock.return_value = (
            mock_endpoint_processor_fixture
        )

>       result = await handler_fixture.register_caller(
            caller_id, endpoint=endpoint, port=port
        )

tsercom/runtime/runtime_data_handler_base_unittest.py:563:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f3719a46050>
caller_id = CallerIdentifier('89e45add-830c-47b4-b4ef-7d11b5c4655a'), args = ()
kwargs = {}, _endpoint = '127.0.0.1', _port = 8080, _context = None
actual_endpoint = '127.0.0.1', actual_port = 8080

    async def register_caller(
        self,
        caller_id: CallerIdentifier,
        *args: Any,
        **kwargs: Any,
    ) -> EndpointDataProcessor[DataTypeT, EventTypeT] | None:
        # pylint: disable=W0221, arguments-differ # Actual signature uses *args, **kwargs for flexibility
        """Registers a caller using either endpoint/port or gRPC context.

        This impl of `RuntimeDataHandler.register_caller` validates inputs,
        extracts endpoint/port from context if provided, then delegates
        to `_register_caller`.

        Args:
            caller_id: The `CallerIdentifier` of the caller.
            *args: Can contain (endpoint, port) or (context,).
            **kwargs: Can contain endpoint="...", port=123 or context=ctx.

        Returns:
            An `EndpointDataProcessor` for the caller, or `None` if
            registration fails.

        Raises:
            ValueError: If arguments are inconsistent.
            TypeError: If context is not of the expected type.
        """
        _endpoint: str | None = None
        _port: int | None = None
        _context: grpc.aio.ServicerContext | None = None

        if len(args) == 1 and isinstance(args[0], grpc.aio.ServicerContext):
            _context = args[0]
        elif (
            len(args) == 2
            and isinstance(args[0], str)
            and isinstance(args[1], int)
        ):
            _endpoint = args[0]
            _port = args[1]
        elif args:
            # pylint: disable=consider-using-f-string
            msg = (
                "Unexpected positional args: %s. Provide (endpoint, port) "
                "or (context,)." % (args,)
            )
            raise ValueError(msg)

        if "endpoint" in kwargs:
            if _endpoint is not None or _context is not None:
                raise ValueError(
                    "Cannot use endpoint via both args & kwargs, or with context."
                )
            _endpoint = kwargs.pop("endpoint")
        if "port" in kwargs:
            if _port is not None or _context is not None:
                raise ValueError(
                    "Cannot use port via both args & kwargs, or with context."
                )
            _port = kwargs.pop("port")
        if "context" in kwargs:
            if (
                _context is not None
                or _endpoint is not None
                or _port is not None
            ):
                raise ValueError(
                    "Cannot use context via args & kwargs, or with endpoint/port."
                )
            _context = kwargs.pop("context")

        if kwargs:
            # pylint: disable=consider-using-f-string
            msg = "Unexpected keyword arguments: %s" % list(kwargs.keys())
            raise ValueError(msg)

        if (_endpoint is None and _port is None) == (_context is None):
            raise ValueError(
                "Provide (endpoint/port) or context, not both/neither."
            )
        if (_port is None) != (_endpoint is None):
            raise ValueError(
                "If 'endpoint' provided, 'port' must be too, and vice-versa."
            )

        actual_endpoint: str
        actual_port: int

        if _context is not None:
            if not isinstance(_context, grpc.aio.ServicerContext):
                # pylint: disable=consider-using-f-string
                msg = (
                    "Expected context: grpc.aio.ServicerContext, got %s."
                    % type(_context).__name__
                )
                raise TypeError(msg)
            extracted_endpoint = get_client_ip(_context)
            extracted_port = get_client_port(_context)

            if extracted_endpoint is None:
                return None
            if extracted_port is None:
                # pylint: disable=consider-using-f-string
                msg = (
                    "Could not get client port from context for endpoint: %s."  # Shortened
                    % extracted_endpoint
                )
                raise ValueError(msg)
            actual_endpoint = extracted_endpoint
            actual_port = extracted_port
        elif _endpoint is not None and _port is not None:
            actual_endpoint = _endpoint
            actual_port = _port
        else:
            raise ValueError(  # Line 147 (Pylint) - Shortened
                "Internal error: Inconsistent endpoint/port/context state."
            )

>       return await self._register_caller(
            caller_id, actual_endpoint, actual_port
        )
E       TypeError: object MagicMock can't be used in 'await' expression

tsercom/runtime/runtime_data_handler_base.py:210: TypeError
_ TestRuntimeDataHandlerBaseRegisterCaller.test_register_caller_with_context_success _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseRegisterCaller object at 0x7f3719ba6c20>
handler_fixture = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f37198ab700>
mock_context_fixture = <MagicMock spec='ServicerContext' id='139874629844848'>
mock_endpoint_processor_fixture = <MagicMock name='mock()' spec='EndpointDataProcessor' id='139874628451872'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f37198abc10>

    @pytest.mark.asyncio
    async def test_register_caller_with_context_success(
        self,
        handler_fixture,
        mock_context_fixture,
        mock_endpoint_processor_fixture,
        mocker,  # Ensure mocker is passed here
    ):
        caller_id = CallerIdentifier.random()
        expected_ip = "192.168.0.1"
        expected_port = 1234
        mock_get_ip = mocker.patch(
            "tsercom.runtime.runtime_data_handler_base.get_client_ip",
            return_value=expected_ip,
        )
        mock_get_port = mocker.patch(
            "tsercom.runtime.runtime_data_handler_base.get_client_port",
            return_value=expected_port,
        )
        handler_fixture._register_caller_mock.return_value = (
            mock_endpoint_processor_fixture
        )

>       result = await handler_fixture.register_caller(
            caller_id, context=mock_context_fixture
        )

tsercom/runtime/runtime_data_handler_base_unittest.py:595:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f37198ab700>
caller_id = CallerIdentifier('0b0fbb76-4f37-4fac-87c7-8f605e37398d'), args = ()
kwargs = {}, _endpoint = None, _port = None
_context = <MagicMock spec='ServicerContext' id='139874629844848'>
extracted_endpoint = '192.168.0.1', extracted_port = 1234
actual_endpoint = '192.168.0.1', actual_port = 1234

    async def register_caller(
        self,
        caller_id: CallerIdentifier,
        *args: Any,
        **kwargs: Any,
    ) -> EndpointDataProcessor[DataTypeT, EventTypeT] | None:
        # pylint: disable=W0221, arguments-differ # Actual signature uses *args, **kwargs for flexibility
        """Registers a caller using either endpoint/port or gRPC context.

        This impl of `RuntimeDataHandler.register_caller` validates inputs,
        extracts endpoint/port from context if provided, then delegates
        to `_register_caller`.

        Args:
            caller_id: The `CallerIdentifier` of the caller.
            *args: Can contain (endpoint, port) or (context,).
            **kwargs: Can contain endpoint="...", port=123 or context=ctx.

        Returns:
            An `EndpointDataProcessor` for the caller, or `None` if
            registration fails.

        Raises:
            ValueError: If arguments are inconsistent.
            TypeError: If context is not of the expected type.
        """
        _endpoint: str | None = None
        _port: int | None = None
        _context: grpc.aio.ServicerContext | None = None

        if len(args) == 1 and isinstance(args[0], grpc.aio.ServicerContext):
            _context = args[0]
        elif (
            len(args) == 2
            and isinstance(args[0], str)
            and isinstance(args[1], int)
        ):
            _endpoint = args[0]
            _port = args[1]
        elif args:
            # pylint: disable=consider-using-f-string
            msg = (
                "Unexpected positional args: %s. Provide (endpoint, port) "
                "or (context,)." % (args,)
            )
            raise ValueError(msg)

        if "endpoint" in kwargs:
            if _endpoint is not None or _context is not None:
                raise ValueError(
                    "Cannot use endpoint via both args & kwargs, or with context."
                )
            _endpoint = kwargs.pop("endpoint")
        if "port" in kwargs:
            if _port is not None or _context is not None:
                raise ValueError(
                    "Cannot use port via both args & kwargs, or with context."
                )
            _port = kwargs.pop("port")
        if "context" in kwargs:
            if (
                _context is not None
                or _endpoint is not None
                or _port is not None
            ):
                raise ValueError(
                    "Cannot use context via args & kwargs, or with endpoint/port."
                )
            _context = kwargs.pop("context")

        if kwargs:
            # pylint: disable=consider-using-f-string
            msg = "Unexpected keyword arguments: %s" % list(kwargs.keys())
            raise ValueError(msg)

        if (_endpoint is None and _port is None) == (_context is None):
            raise ValueError(
                "Provide (endpoint/port) or context, not both/neither."
            )
        if (_port is None) != (_endpoint is None):
            raise ValueError(
                "If 'endpoint' provided, 'port' must be too, and vice-versa."
            )

        actual_endpoint: str
        actual_port: int

        if _context is not None:
            if not isinstance(_context, grpc.aio.ServicerContext):
                # pylint: disable=consider-using-f-string
                msg = (
                    "Expected context: grpc.aio.ServicerContext, got %s."
                    % type(_context).__name__
                )
                raise TypeError(msg)
            extracted_endpoint = get_client_ip(_context)
            extracted_port = get_client_port(_context)

            if extracted_endpoint is None:
                return None
            if extracted_port is None:
                # pylint: disable=consider-using-f-string
                msg = (
                    "Could not get client port from context for endpoint: %s."  # Shortened
                    % extracted_endpoint
                )
                raise ValueError(msg)
            actual_endpoint = extracted_endpoint
            actual_port = extracted_port
        elif _endpoint is not None and _port is not None:
            actual_endpoint = _endpoint
            actual_port = _port
        else:
            raise ValueError(  # Line 147 (Pylint) - Shortened
                "Internal error: Inconsistent endpoint/port/context state."
            )

>       return await self._register_caller(
            caller_id, actual_endpoint, actual_port
        )
E       TypeError: object MagicMock can't be used in 'await' expression

tsercom/runtime/runtime_data_handler_base.py:210: TypeError
=========================== short test summary info ============================
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseRegisterCaller::test_register_caller_with_endpoint_port_success
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseRegisterCaller::test_register_caller_with_context_success
ERROR tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_desynchronize
ERROR tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_deregister_caller
ERROR tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_process_data_with_datetime
ERROR tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_process_data_with_server_timestamp
ERROR tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_process_data_no_timestamp
==================== 2 failed, 14 passed, 5 errors in 0.60s ====================

"""Manages thread-safe bidirectional mappings for caller identification.

This module provides the `IdTracker` class, which facilitates associating
`CallerIdentifier` objects with network addresses (IP/port) and optionally
with custom data generated by a factory. It ensures that these mappings can be
accessed and modified in a thread-safe manner.
"""

import threading
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterator,
    List,
    Optional,
    TypeVar,
    overload,
)

from tsercom.caller_id.caller_identifier import CallerIdentifier

TrackedDataT = TypeVar("TrackedDataT")


class IdTracker(Generic[TrackedDataT]):
    """Tracks associations between CallerIdentifiers, network addresses, and optional data.

    This class provides a thread-safe, bidirectional dictionary-like structure
    to map `CallerIdentifier` instances to (address, port) tuples and vice-versa.
    It can also store arbitrary data associated with each `CallerIdentifier` if
    a `data_factory` is provided during initialization.

    If a `data_factory` is supplied, it will be called (without arguments)
    each time a new `CallerIdentifier` is successfully added, and its return
    value will be stored. This allows for associating stateful objects (e.g.,
    per-client pollers or buffers) with each tracked caller.

    The `get` and `try_get` methods will include this tracked data in their
    return tuples if a `data_factory` was used. If no `data_factory` was
    provided (or it was `None`), the position for tracked data in the return
    tuples will be `None`.

    All public methods are thread-safe.

    Type Args:
        TrackedDataT: The type of the custom data to be associated with each
            `CallerIdentifier` if a `data_factory` is provided.
    """

    def __init__(
        self, data_factory: Optional[Callable[[], TrackedDataT]] = None
    ) -> None:
        """Initializes the IdTracker.

        Args:
            data_factory: An optional callable that takes no arguments and returns
                an object of type `TrackedDataT`. If provided, this factory
                is used to generate and store data associated with each new
                `CallerIdentifier` added to the tracker. If `None`, no custom
                data is stored besides the ID-address mapping.
        """
        self.__data_factory: Optional[Callable[[], TrackedDataT]] = (
            data_factory
        )
        self.__lock: threading.Lock = threading.Lock()
        self.__address_to_id: Dict[tuple[str, int], CallerIdentifier] = {}
        self.__id_to_address: Dict[CallerIdentifier, tuple[str, int]] = {}
        self.__data_map: Dict[CallerIdentifier, TrackedDataT] = {}

    # pylint: disable=too-many-branches # Handles multiple lookup methods by design
    @overload
    def try_get(
        self, caller_id_obj: CallerIdentifier
    ) -> Optional[tuple[str, int, Optional[TrackedDataT]]]:
        """Tries to get address and data by CallerIdentifier.

        Args:
            caller_id_obj: The CallerIdentifier to look up.

        Returns:
            Optional[tuple[str, int, Optional[TrackedDataT]]]:
                A tuple (address, port, tracked_data) if found, else None.
                `tracked_data` is None if no data_factory was used.
        """
        ...

    @overload
    def try_get(
        self, address: str, port: int
    ) -> Optional[tuple[CallerIdentifier, Optional[TrackedDataT]]]:
        """Tries to get CallerIdentifier and data by address/port.

        Args:
            address: The IP address or hostname.
            port: The port number.

        Returns:
            Optional[tuple[CallerIdentifier, Optional[TrackedDataT]]]:
                A tuple (caller_identifier, tracked_data) if found, else None.
                `tracked_data` is None if no data_factory was used.
        """
        ...

    def try_get(
        self, *args: Any, **kwargs: Any
    ) -> Optional[
        tuple[str, int, Optional[TrackedDataT]]
        | tuple[CallerIdentifier, Optional[TrackedDataT]]
    ]:
        """Attempts to retrieve associated information for a given identifier or address.

        This method provides a way to look up mappings without raising an
        exception if the key is not found.

        If looking up by `CallerIdentifier` (`caller_id_obj`):
            Returns a 3-tuple `(address: str, port: int, tracked_data: Optional[TrackedDataT])`
            if the `CallerIdentifier` is found. `tracked_data` is the result of
            the `data_factory` if one was provided and the ID was added with it,
            otherwise it is `None`.

        If looking up by network address (`address`, `port`):
            Returns a 2-tuple `(caller_identifier: CallerIdentifier, tracked_data: Optional[TrackedDataT])`
            if the address/port combination is found. `tracked_data` is determined
            as above.

        Args:
            *args: Can be `(CallerIdentifier)` or `(address_str, port_int)`.
            **kwargs: Can be `id=CallerIdentifier` or `address=str, port=int`.

        Returns:
            The associated mapping as a tuple if found, otherwise `None`.
            The structure of the tuple depends on the lookup method (see above).

        Raises:
            ValueError: If incorrect arguments are provided (e.g., mixing
                ID and address lookups, or providing partial address information).
        """
        _id: Optional[CallerIdentifier] = None
        _address: Optional[str] = None
        _port: Optional[int] = None

        if args:
            if len(args) == 1 and isinstance(args[0], CallerIdentifier):
                _id = args[0]
            elif (
                len(args) == 2
                and isinstance(args[0], str)
                and isinstance(args[1], int)
            ):
                _address = args[0]
                _port = args[1]
            elif len(args) > 0:
                raise ValueError(
                    "Invalid positional args. Use CallerIdentifier or (address, port). "
                    f"Got: {args}"
                )

        # Legacy kwarg 'id' for CallerIdentifier lookup
        if "id" in kwargs:
            if _id is not None or _address is not None or _port is not None:
                raise ValueError(
                    "Cannot mix 'id' kwarg with positional or other "
                    "address/port kwargs."
                )
            kw_id = kwargs.pop("id")
            if not isinstance(kw_id, CallerIdentifier):
                raise ValueError(
                    f"'id' kwarg must be CallerIdentifier. Got {type(kw_id)}"
                )
            _id = kw_id

        if "address" in kwargs:
            if (
                _id is not None or _address is not None
            ):  # Check against already set _address
                raise ValueError(
                    "Cannot mix 'address' kwarg with 'id' or positional address."
                )
            kw_address = kwargs.pop("address")
            if not isinstance(kw_address, str):
                raise ValueError(
                    f"'address' kwarg must be str. Got {type(kw_address)}"
                )
            _address = kw_address

        if "port" in kwargs:
            if (
                _id is not None or _port is not None
            ):  # Check against already set _port
                raise ValueError(
                    "Cannot mix 'port' kwarg with 'id' or positional port."
                )
            kw_port = kwargs.pop("port")
            if not isinstance(kw_port, int):
                raise ValueError(
                    f"'port' kwarg must be int. Got {type(kw_port)}"
                )
            _port = kw_port

        if kwargs:  # Any remaining kwargs are unexpected
            raise ValueError(f"Unexpected kwargs: {list(kwargs.keys())}")

        # Validate that either ID or (address and port) is provided, but not both/neither.
        if (_id is None) == (_address is None and _port is None):
            raise ValueError(
                "Provide CallerIdentifier or (address and port), not both or neither."
            )
        if (_address is None) != (_port is None):  # XOR condition
            raise ValueError(
                "If 'address' is provided, 'port' must also be, and vice-versa."
            )

        with self.__lock:
            if _id is not None:  # Lookup by CallerIdentifier
                address_port_tuple = self.__id_to_address.get(_id)
                if address_port_tuple is None:
                    return None
                tracked_data = self.__data_map.get(
                    _id
                )  # Will be None if not present
                return (
                    address_port_tuple[0],
                    address_port_tuple[1],
                    tracked_data,
                )

            if (
                _address is not None and _port is not None
            ):  # Lookup by address/port
                caller_id_obj = self.__address_to_id.get((_address, _port))
                if caller_id_obj is None:
                    return None
                tracked_data = self.__data_map.get(
                    caller_id_obj
                )  # Will be None if not present
                return caller_id_obj, tracked_data

        return None  # Should be logically unreachable due to prior validation

    @overload
    def get(
        self, caller_id_obj: CallerIdentifier
    ) -> tuple[str, int, Optional[TrackedDataT]]:
        """Gets address and data by CallerIdentifier, raises KeyError if not found.

        Args:
            caller_id_obj: The CallerIdentifier to look up.

        Returns:
            tuple[str, int, Optional[TrackedDataT]]:
                A tuple (address, port, tracked_data).
                `tracked_data` is None if no data_factory was used.

        Raises:
            KeyError: If the `caller_id_obj` is not found.
        """
        ...

    @overload
    def get(
        self, address: str, port: int
    ) -> tuple[CallerIdentifier, Optional[TrackedDataT]]:
        """Gets CallerIdentifier and data by address/port, raises KeyError if not found.

        Args:
            address: The IP address or hostname.
            port: The port number.

        Returns:
            tuple[CallerIdentifier, Optional[TrackedDataT]]:
                A tuple (caller_identifier, tracked_data).
                `tracked_data` is None if no data_factory was used.

        Raises:
            KeyError: If the address/port combination is not found.
        """
        ...

    def get(
        self, *args: Any, **kwargs: Any
    ) -> (
        tuple[str, int, Optional[TrackedDataT]]
        | tuple[CallerIdentifier, Optional[TrackedDataT]]
    ):
        """Retrieves associated information, raising KeyError if not found.

        This method behaves like `try_get` but raises a `KeyError` if the
        lookup key (either `CallerIdentifier` or address/port combination)
        is not found in the tracker.

        Args:
            *args: Can be `(CallerIdentifier)` or `(address_str, port_int)`.
            **kwargs: Can be `id=CallerIdentifier` or `address=str, port=int`.

        Returns:
            The associated mapping as a tuple. The structure of the tuple
            depends on the lookup method (see `try_get` for details).

        Raises:
            ValueError: If incorrect arguments are provided.
            KeyError: If the lookup key is not found.
        """
        resolved_result = self.try_get(*args, **kwargs)
        if resolved_result is None:
            query_repr = ""
            if args:
                query_repr = f"args={args}"
            if kwargs:
                sep = ", " if args else ""
                query_repr += f"{sep}kwargs={kwargs}"
            raise KeyError(f"Key not found for query: {query_repr}")
        return resolved_result

    def add(
        self, caller_id_obj: CallerIdentifier, address: str, port: int
    ) -> None:
        """Adds or updates a bidirectional mapping.

        If the `caller_id_obj` already exists, its associated address/port
        and tracked data (if a `data_factory` was used for the original add)
        will be updated. If the new address/port combination is already mapped
        to a *different* `CallerIdentifier`, a `KeyError` is raised.

        If a `data_factory` was provided during `IdTracker` initialization,
        it is called (only if `caller_id_obj` is new to `__data_map` or was previously removed)
        and its result is stored with the `caller_id_obj`.

        Args:
            caller_id_obj: The `CallerIdentifier` for the mapping.
            address: The IP address or hostname.
            port: The port number.

        Raises:
            KeyError: If the `address` and `port` combination is already mapped
                to a different `CallerIdentifier`.
        """
        with self.__lock:
            # If the ID already exists, remove its old address mapping to allow update
            if caller_id_obj in self.__id_to_address:
                old_address_port = self.__id_to_address.pop(caller_id_obj)
                # Also remove old_address_port if it pointed back to this caller_id
                if self.__address_to_id.get(old_address_port) == caller_id_obj:
                    self.__address_to_id.pop(old_address_port)

            # Check if the new address/port is already mapped to a *different* ID
            current_id_for_address = self.__address_to_id.get((address, port))
            if (
                current_id_for_address is not None
                and current_id_for_address != caller_id_obj
            ):
                raise KeyError(
                    f"New address ({address}:{port}) already mapped to a different ID "
                    f"({current_id_for_address}). Cannot reassign to {caller_id_obj}."
                )

            self.__address_to_id[(address, port)] = caller_id_obj
            self.__id_to_address[caller_id_obj] = (address, port)

            # Add/update data from data_factory only if factory exists
            # and if the id is new to the data_map or was previously cleared.
            # The current logic effectively re-calls factory on every add if factory exists.
            # To call factory only once per ID: check `if caller_id_obj not in self.__data_map:`
            if self.__data_factory is not None:
                self.__data_map[caller_id_obj] = self.__data_factory()

    def has_id(self, caller_id_obj: CallerIdentifier) -> bool:
        """Checks if the given `CallerIdentifier` is tracked.

        Args:
            caller_id_obj: The `CallerIdentifier` to check.

        Returns:
            True if the `CallerIdentifier` is present, False otherwise.
        """
        with self.__lock:
            return caller_id_obj in self.__id_to_address

    def has_address(self, address: str, port: int) -> bool:
        """Checks if the given address/port combination is tracked.

        Args:
            address: The IP address or hostname.
            port: The port number.

        Returns:
            True if the address/port combination is present, False otherwise.
        """
        with self.__lock:
            return (address, port) in self.__address_to_id

    def __len__(self) -> int:
        """Returns the number of unique `CallerIdentifier` mappings stored."""
        with self.__lock:
            # Asserting consistency, should ideally always be true.
            assert len(self.__id_to_address) == len(self.__address_to_id)
            return len(self.__id_to_address)

    def __iter__(self) -> Iterator[CallerIdentifier]:
        """Returns an iterator over the tracked `CallerIdentifier`s."""
        with self.__lock:
            # Returns an iterator over a copy of the keys to allow safe iteration
            # if modifications occur in another thread (though individual operations are locked).
            return iter(list(self.__id_to_address.keys()))

    def remove(self, caller_id_obj: CallerIdentifier) -> bool:
        """Removes a `CallerIdentifier` and all its associated mappings.

        This includes its address/port mapping and any tracked data associated
        via the `data_factory`.

        Args:
            caller_id_obj: The `CallerIdentifier` to remove.

        Returns:
            True if the `CallerIdentifier` was found and removed, False otherwise.
        """
        with self.__lock:
            if caller_id_obj not in self.__id_to_address:
                return False

            address_port_tuple = self.__id_to_address.pop(caller_id_obj)

            if caller_id_obj in self.__data_map:  # Conditional deletion
                del self.__data_map[caller_id_obj]

            # Also remove the reverse mapping
            if self.__address_to_id.get(address_port_tuple) == caller_id_obj:
                del self.__address_to_id[address_port_tuple]

            return True

    def get_all_tracked_data(self) -> List[TrackedDataT]:
        """Retrieves all data items stored in the tracker.

        This method is thread-safe. It returns a new list containing
        all values from the internal data map.

        Returns:
            A list of all TrackedDataT items. Returns an empty list
            if no data is tracked or if no data_factory was used.
        """
        with self.__lock:
            return list(self.__data_map.values())

============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-8.3.5, pluggy-1.5.0
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, timeout-2.4.0, mock-3.14.1, anyio-4.9.0, cov-6.1.1, json-report-1.5.0, metadata-3.1.1
asyncio: mode=strict, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
timeout: 120.0s
timeout method: signal
timeout func_only: False
collected 519 items

tsercom/api/local_process/local_runtime_factory_factory_unittest.py .... [  0%]
...                                                                      [  1%]
tsercom/api/local_process/local_runtime_factory_unittest.py ....         [  2%]
tsercom/api/local_process/runtime_command_bridge_unittest.py ........... [  4%]
......                                                                   [  5%]
tsercom/api/local_process/runtime_wrapper_unittest.py .........          [  7%]
tsercom/api/runtime_manager_unittest.py F...F..FF.F..F.FF                [ 10%]
tsercom/api/split_process/data_reader_sink_unittest.py ......            [ 11%]
tsercom/api/split_process/data_reader_source_unittest.py ..........      [ 13%]
tsercom/api/split_process/event_source_unittest.py .......               [ 14%]
tsercom/api/split_process/remote_runtime_factory_unittest.py ....        [ 15%]
tsercom/api/split_process/runtime_command_source_unittest.py .........   [ 17%]
tsercom/api/split_process/shim_runtime_handle_unittest.py ........       [ 18%]
tsercom/api/split_process/split_process_error_watcher_sink_unittest.py . [ 19%]
..                                                                       [ 19%]
tsercom/api/split_process/split_process_error_watcher_source_unittest.py . [ 19%]
......                                                                   [ 20%]
tsercom/api/split_process/split_runtime_factory_factory_unittest.py ..   [ 21%]
tsercom/caller_id/caller_id_map_unittest.py .....                        [ 22%]
tsercom/caller_id/caller_identifier_unittest.py ..............           [ 24%]
tsercom/caller_id/caller_identifier_waiter_unittest.py ....              [ 25%]
tsercom/caller_id/client_id_fetcher_unittest.py .......                  [ 26%]
tsercom/data/data_host_base_unittest.py .....                            [ 27%]
tsercom/data/data_timeout_tracker_unittest.py ..........                 [ 29%]
tsercom/data/exposed_data_with_responder_unittest.py .....               [ 30%]
tsercom/data/remote_data_aggregator_impl_unittest.py ................... [ 34%]
.                                                                        [ 34%]
tsercom/data/remote_data_organizer_unittest.py ......................... [ 39%]
.                                                                        [ 39%]
tsercom/discovery/discovery_host_unittest.py .......                     [ 41%]
tsercom/discovery/mdns/instance_listener_unittest.py ...........         [ 43%]
tsercom/discovery/mdns/instance_publisher_unittest.py .................. [ 46%]
.                                                                        [ 46%]
tsercom/discovery/service_connector_unittest.py ........                 [ 48%]
tsercom/discovery_e2etest.py ......                                      [ 49%]
tsercom/rpc/connection/client_disconnection_retrier_unittest.py .......  [ 50%]
tsercom/rpc/serialization/caller_id_extraction_unittest.py ............  [ 53%]
tsercom/rpc_e2etest.py .............                                     [ 55%]
tsercom/runtime/client/client_runtime_data_handler_unittest.py ......    [ 56%]
tsercom/runtime/client/timesync_tracker_unittest.py ......               [ 57%]
tsercom/runtime/id_tracker_unittest.py ...............                   [ 60%]
tsercom/runtime/runtime_config_unittest.py ..........F....               [ 63%]
tsercom/runtime/runtime_data_handler_base_unittest.py .................F [ 67%]
FF.                                                                      [ 67%]
tsercom/runtime/runtime_main_unittest.py ...FF                           [ 68%]
tsercom/runtime/server/server_runtime_data_handler_unittest.py .....     [ 69%]
tsercom/runtime_e2etest.py ......                                        [ 70%]
tsercom/threading/aio/aio_utils_unittest.py .......                      [ 72%]
tsercom/threading/aio/event_loop_factory_unittest.py .                   [ 72%]
tsercom/threading/aio/global_event_loop_unittest.py .........            [ 74%]
tsercom/threading/async_poller_unittest.py ...............               [ 77%]
tsercom/threading/atomic_unittest.py ......                              [ 78%]
tsercom/threading/multiprocess/multiprocess_queue_sink_unittest.py ....  [ 78%]
tsercom/threading/thread_safe_queue_unittest.py .......                  [ 80%]
tsercom/threading/thread_watcher_unittest.py ............                [ 82%]
tsercom/threading/throwing_thread_pool_executor_unittest.py ........     [ 84%]
tsercom/threading/throwing_thread_unittest.py .....s                     [ 85%]
tsercom/timesync/client/client_synchronized_clock_unittest.py .......... [ 87%]
                                                                         [ 87%]
tsercom/timesync/client/fake_time_sync_client_unittest.py ........       [ 88%]
tsercom/timesync/client/time_sync_client_unittest.py ..............      [ 91%]
tsercom/timesync/common/fake_synchronized_clock_unittest.py ...          [ 92%]
tsercom/timesync/common/synchronized_clock_unittest.py .....             [ 93%]
tsercom/timesync/common/synchronized_timestamp_unittest.py ............. [ 95%]
..                                                                       [ 95%]
tsercom/timesync/server/server_synchronized_clock_unittest.py ...        [ 96%]
tsercom/util/ip_unittest.py ........                                     [ 98%]
tsercom/util/is_running_tracker_unittest.py ........                     [ 99%]
tsercom/util/stopable_unittest.py ..                                     [100%]

=================================== FAILURES ===================================
___________ TestRuntimeManager.test_initialization_with_no_arguments ___________

self = <MagicMock name='LFF_ConstructorProxy' id='139679103264144'>
args = (<MagicMock name='ThreadWatcher().create_tracked_thread_pool_executor()' id='139679101719344'>,)
kwargs = {}
msg = "Expected 'LFF_ConstructorProxy' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'LFF_ConstructorProxy' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError

During handling of the above exception, another exception occurred:

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f099431fbe0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09934273d0>

    def test_initialization_with_no_arguments(self, mocker):
        """Test RuntimeManager() with no arguments: Ensure internal dependencies are created."""
        mock_tw = mocker.patch(
            "tsercom.api.runtime_manager.ThreadWatcher", autospec=True
        )
        mock_lff_class = mocker.patch(
            "tsercom.api.runtime_manager.LocalRuntimeFactoryFactory"
        )
        mock_lff_constructor_callable = mocker.MagicMock(
            name="LFF_ConstructorProxy"
        )
        mock_lff_class.__getitem__.return_value = mock_lff_constructor_callable
        mock_sff_class = mocker.patch(
            "tsercom.api.runtime_manager.SplitRuntimeFactoryFactory"
        )
        mock_sff_constructor_callable = mocker.MagicMock(
            name="SFF_ConstructorProxy"
        )
        mock_sff_class.__getitem__.return_value = mock_sff_constructor_callable
        mock_pc_constructor = mocker.patch(
            "tsercom.api.runtime_manager.ProcessCreator", autospec=True
        )
        mock_sewsf_constructor = mocker.patch(
            "tsercom.api.runtime_manager.SplitErrorWatcherSourceFactory",
            autospec=True,
        )
        mock_thread_watcher_instance = mock_tw.return_value
        mock_thread_pool = mocker.MagicMock()
        mock_thread_watcher_instance.create_tracked_thread_pool_executor.return_value = (
            mock_thread_pool
        )

        manager = RuntimeManager(is_testing=True)

        mock_tw.assert_called_once()
>       mock_lff_constructor_callable.assert_called_once_with(mock_thread_pool)
E       AssertionError: Expected 'LFF_ConstructorProxy' to be called once. Called 0 times.

tsercom/api/runtime_manager_unittest.py:137: AssertionError
___________________ TestRuntimeManager.test_start_in_process ___________________

args = (<tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f099431fee0>,)
keywargs = {'manager_with_mocks': <tsercom.api.runtime_manager.RuntimeManager object at 0x7f0993478880>, 'mock_local_rff': <Magic...untimeInitializer' id='139679102382000'>, 'mock_thread_watcher': <MagicMock spec='ThreadWatcher' id='139679102301712'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.10/unittest/mock.py:1376:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
/usr/lib/python3.10/unittest/mock.py:1358: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.10/contextlib.py:492: in enter_context
    result = _cm_type.__enter__(cm)
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f099431c340>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'initialize_runtimes'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
_________________ TestRuntimeManager.test_start_out_of_process _________________

args = (<tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f0994357ca0>,)
keywargs = {'manager_with_mocks': <tsercom.api.runtime_manager.RuntimeManager object at 0x7f0993318ac0>, 'mock_process_creator': ... id='139679100930944'>, 'mock_split_ewsf': <MagicMock spec='SplitErrorWatcherSourceFactory' id='139679101445040'>, ...}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.10/unittest/mock.py:1376:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
/usr/lib/python3.10/unittest/mock.py:1358: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.10/contextlib.py:492: in enter_context
    result = _cm_type.__enter__(cm)
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f099431c190>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'remote_process_main'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
________ TestRuntimeManager.test_start_out_of_process_is_testing_daemon ________

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f0994356da0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09933c38e0>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09933224a0>

    def test_start_out_of_process_is_testing_daemon(
        self, mocker, manager_with_mocks
    ):
        manager_with_mocks._RuntimeManager__is_testing = True
        mocker.patch(
            "tsercom.api.runtime_manager.create_tsercom_event_loop_from_watcher"
        )
        mocker.patch(
            "tsercom.api.runtime_manager.create_multiprocess_queues",
            return_value=(MagicMock(), MagicMock()),
        )
>       mocker.patch("tsercom.api.runtime_manager.remote_process_main")

tsercom/api/runtime_manager_unittest.py:414:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:439: in __call__
    return self._start_patch(
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:257: in _start_patch
    mocked: MockType = p.start()
/usr/lib/python3.10/unittest/mock.py:1595: in start
    result = self.__enter__()
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f09935d8f70>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'remote_process_main'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
________ TestRuntimeManager.test_run_until_exception_error_watcher_none ________

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f0994357dc0>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09933da9e0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f0993474190>

    def test_run_until_exception_error_watcher_none(
        self, manager_with_mocks, mocker
    ):
        mocker.patch.object(
            RuntimeManager,
            "has_started",
            new_callable=PropertyMock,
            return_value=True,
        )
        manager_with_mocks._RuntimeManager__thread_watcher = None
        with pytest.raises(
            RuntimeError,
            match="Error watcher is not available. Ensure the RuntimeManager has been properly started.",
        ):
>           manager_with_mocks.run_until_exception()

tsercom/api/runtime_manager_unittest.py:443:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09933da9e0>

    def run_until_exception(self) -> None:
        """Blocks the calling thread until an exception is reported from any managed runtime.

        This method relies on the internal `ThreadWatcher` (for in-process runtimes)
        or the `SplitProcessErrorWatcherSource` (for out-of-process runtimes via
        the `ThreadWatcher`) to signal an exception. When an exception is caught,
        this method re-raises it in the calling thread.

        Raises:
            Exception: The first exception propagated from any managed runtime.
            RuntimeError: If the manager has not been started or if the
                necessary error watching components are not available.
        """
        if not self.has_started:
            raise RuntimeError("RuntimeManager has not been started.")
        # The __thread_watcher is initialized in __init__, so it should always be present.
>       self.__thread_watcher.run_until_exception()
E       AttributeError: 'NoneType' object has no attribute 'run_until_exception'

tsercom/api/runtime_manager.py:373: AttributeError
________ TestRuntimeManager.test_check_for_exception_error_watcher_none ________

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f0994356800>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09933ae950>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09934057e0>

    def test_check_for_exception_error_watcher_none(
        self, manager_with_mocks, mocker
    ):
        mocker.patch.object(
            RuntimeManager,
            "has_started",
            new_callable=PropertyMock,
            return_value=True,
        )
        manager_with_mocks._RuntimeManager__thread_watcher = None
        with pytest.raises(
            RuntimeError,
            match="Error watcher is not available. Ensure the RuntimeManager has been properly started.",
        ):
>           manager_with_mocks.check_for_exception()

tsercom/api/runtime_manager_unittest.py:480:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09933ae950>

    def check_for_exception(self) -> None:
        """Checks for and re-raises the first caught exception from managed runtimes.

        If an exception has been propagated from any runtime and caught by the
        manager\'s error watching mechanisms, this method re-raises that
        exception in the calling thread. If no exceptions have been caught,
        this method does nothing. This method is thread-safe.

        Raises:
            Exception: The first exception propagated from any managed runtime, if any.
            RuntimeError: If the manager has been started but the internal
                `ThreadWatcher` is somehow not available (should not happen
                with proper initialization).
        """
        if not self.has_started:
            return
        # The __thread_watcher is initialized in __init__.
>       self.__thread_watcher.check_for_exception()
E       AttributeError: 'NoneType' object has no attribute 'check_for_exception'

tsercom/api/runtime_manager.py:392: AttributeError
_________ TestRuntimeManager.test_runtime_future_populator_indirectly __________

args = (<tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f0994355540>,)
keywargs = {'manager_with_mocks': <tsercom.api.runtime_manager.RuntimeManager object at 0x7f099332b880>, 'mock_local_rff': <Magic...Factory' id='139679101623392'>, 'mock_runtime_initializer': <MagicMock spec='RuntimeInitializer' id='139679101006512'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.10/unittest/mock.py:1376:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/usr/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
/usr/lib/python3.10/unittest/mock.py:1358: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.10/contextlib.py:492: in enter_context
    result = _cm_type.__enter__(cm)
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f099431c2e0>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'initialize_runtimes'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
_____ TestRuntimeManager.test_start_out_of_process_process_creation_fails ______

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f0994354e50>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09933309d0>
mock_process_creator = <MagicMock spec='ProcessCreator' id='139679101724144'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09936becb0>

    def test_start_out_of_process_process_creation_fails(
        self, manager_with_mocks, mock_process_creator, mocker
    ):
        mock_process_creator.create_process.return_value = None
        mocker.patch(
            "tsercom.api.runtime_manager.create_tsercom_event_loop_from_watcher"
        )
        mocker.patch(
            "tsercom.api.runtime_manager.create_multiprocess_queues",
            return_value=(MagicMock(), MagicMock()),
        )
>       mocker.patch("tsercom.api.runtime_manager.remote_process_main")

tsercom/api/runtime_manager_unittest.py:562:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:439: in __call__
    return self._start_patch(
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:257: in _start_patch
    mocked: MockType = p.start()
/usr/lib/python3.10/unittest/mock.py:1595: in start
    result = self.__enter__()
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f0993386c80>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'remote_process_main'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
______________ TestRuntimeConfig.test_invalid_service_type_string ______________

self = <tsercom.runtime.runtime_config_unittest.TestRuntimeConfig object at 0x7f09934167d0>

    def test_invalid_service_type_string(self):
        """Test initialization with an invalid service_type string raises ValueError."""
        invalid_type = "InvalidType"
        with pytest.raises(ValueError) as excinfo:
            RuntimeConfig(service_type=invalid_type)
>       assert f"Invalid service type: {invalid_type}" == str(excinfo.value)
E       assert 'Invalid serv...: InvalidType' == "Invalid serv... or 'Server'."
E
E         - Invalid service_type string: 'InvalidType'. Must be 'Client' or 'Server'.
E         + Invalid service type: InvalidType

tsercom/runtime/runtime_config_unittest.py:118: AssertionError
_ TestRuntimeDataHandlerBaseRegisterCaller.test_register_caller_mutex_args_none _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseRegisterCaller object at 0x7f0993b2d0f0>
handler_fixture = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f0991b8d1e0>

    @pytest.mark.asyncio
    async def test_register_caller_mutex_args_none(self, handler_fixture):
        """Test providing neither endpoint/port nor context raises ValueError."""
        caller_id = CallerIdentifier.random()
        with pytest.raises(ValueError) as excinfo:
            await handler_fixture.register_caller(
                caller_id
            )  # No endpoint, port or context
>       assert (
            "Provide (endpoint/port) or context, not both/neither."  # Updated message
            in str(excinfo.value)
        )
E       AssertionError: assert 'Provide (endpoint/port) or context, not both/neither.' in 'Provide (endpoint and port) or context, but not both or neither.'
E        +  where 'Provide (endpoint and port) or context, but not both or neither.' = str(ValueError('Provide (endpoint and port) or context, but not both or neither.'))
E        +    where ValueError('Provide (endpoint and port) or context, but not both or neither.') = <ExceptionInfo ValueError('Provide (endpoint and port) or context, but not both or neither.') tblen=2>.value

tsercom/runtime/runtime_data_handler_base_unittest.py:733: AssertionError
_ TestRuntimeDataHandlerBaseRegisterCaller.test_register_caller_endpoint_without_port _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseRegisterCaller object at 0x7f0993b2edd0>
handler_fixture = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f0991b01c00>

    @pytest.mark.asyncio
    async def test_register_caller_endpoint_without_port(
        self, handler_fixture
    ):
        """Test providing endpoint without port raises ValueError."""
        caller_id = CallerIdentifier.random()
        with pytest.raises(ValueError) as excinfo:
            await handler_fixture.register_caller(
                caller_id, endpoint="1.2.3.4"
            )  # Port is None
>       assert (
            "If 'endpoint' provided, 'port' must be too, and vice-versa."  # Updated message
            in str(excinfo.value)
        )
E       assert "If 'endpoint' provided, 'port' must be too, and vice-versa." in "If 'endpoint' is provided, 'port' must also be, and vice-versa."
E        +  where "If 'endpoint' is provided, 'port' must also be, and vice-versa." = str(ValueError("If 'endpoint' is provided, 'port' must also be, and vice-versa."))
E        +    where ValueError("If 'endpoint' is provided, 'port' must also be, and vice-versa.") = <ExceptionInfo ValueError("If 'endpoint' is provided, 'port' must also be, and vice-versa.") tblen=2>.value

tsercom/runtime/runtime_data_handler_base_unittest.py:748: AssertionError
_ TestRuntimeDataHandlerBaseRegisterCaller.test_register_caller_port_without_endpoint _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseRegisterCaller object at 0x7f0993b271f0>
handler_fixture = <tsercom.runtime.runtime_data_handler_base_unittest.ConcreteRuntimeDataHandler object at 0x7f099331a2c0>

    @pytest.mark.asyncio
    async def test_register_caller_port_without_endpoint(
        self, handler_fixture
    ):
        """Test providing port without endpoint raises ValueError."""
        caller_id = CallerIdentifier.random()
        with pytest.raises(ValueError) as excinfo:
            await handler_fixture.register_caller(
                caller_id, port=1234
            )  # Endpoint is None
>       assert (
            "If 'endpoint' provided, 'port' must be too, and vice-versa."  # Updated message
            in str(excinfo.value)
        )
E       assert "If 'endpoint' provided, 'port' must be too, and vice-versa." in "If 'endpoint' is provided, 'port' must also be, and vice-versa."
E        +  where "If 'endpoint' is provided, 'port' must also be, and vice-versa." = str(ValueError("If 'endpoint' is provided, 'port' must also be, and vice-versa."))
E        +    where ValueError("If 'endpoint' is provided, 'port' must also be, and vice-versa.") = <ExceptionInfo ValueError("If 'endpoint' is provided, 'port' must also be, and vice-versa.") tblen=2>.value

tsercom/runtime/runtime_data_handler_base_unittest.py:763: AssertionError
_________________ TestRemoteProcessMain.test_normal_execution __________________

self = <tsercom.runtime.runtime_main_unittest.TestRemoteProcessMain object at 0x7f0993b60340>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f0993381cc0>

    def test_normal_execution(
        self,
        mocker,
    ):
        """Tests the normal execution path of remote_process_main."""
        mock_clear_event_loop = mocker.patch(
            "tsercom.runtime.runtime_main.clear_tsercom_event_loop"
        )
        MockThreadWatcher = mocker.patch(
            "tsercom.runtime.runtime_main.ThreadWatcher",
            return_value=mocker.Mock(spec=ThreadWatcher),
        )
        mock_create_event_loop = mocker.patch(
            "tsercom.runtime.runtime_main.create_tsercom_event_loop_from_watcher"
        )
        MockSplitProcessErrorWatcherSink = mocker.patch(
            "tsercom.runtime.runtime_main.SplitProcessErrorWatcherSink"
        )
        mock_initialize_runtimes = mocker.patch(
            "tsercom.runtime.runtime_main.initialize_runtimes"
        )
        mock_run_on_event_loop = mocker.patch(
            "tsercom.runtime.runtime_main.run_on_event_loop"
        )

        mock_factories = [mocker.Mock(spec=RuntimeFactory)]
        mock_error_queue = mocker.Mock(spec=MultiprocessQueueSink)

        mock_runtime1 = mocker.Mock(spec=Runtime)
        mock_runtime1.stop = mocker.Mock(name="runtime1_stop")
        mock_runtime2 = mocker.Mock(spec=Runtime)
        mock_runtime2.stop = mocker.Mock(name="runtime2_stop")
        mock_initialize_runtimes.return_value = [mock_runtime1, mock_runtime2]

        mock_sink_instance = MockSplitProcessErrorWatcherSink.return_value

        remote_process_main(mock_factories, mock_error_queue)

        mock_clear_event_loop.assert_called_once()
        MockThreadWatcher.assert_called_once()
        mock_create_event_loop.assert_called_once_with(
            MockThreadWatcher.return_value
        )
        MockSplitProcessErrorWatcherSink.assert_called_once_with(
            MockThreadWatcher.return_value, mock_error_queue
        )
        mock_initialize_runtimes.assert_called_once_with(
            MockThreadWatcher.return_value, mock_factories, is_testing=False
        )
        mock_sink_instance.run_until_exception.assert_called_once()

>       assert mock_run_on_event_loop.call_count == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <MagicMock name='run_on_event_loop' id='139679102299312'>.call_count

tsercom/runtime/runtime_main_unittest.py:476: AssertionError
_________ TestRemoteProcessMain.test_exception_in_run_until_exception __________

self = <tsercom.runtime.runtime_main_unittest.TestRemoteProcessMain object at 0x7f0993b62d70>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f0993465b10>

    def test_exception_in_run_until_exception(
        self,
        mocker,
    ):
        """Tests error handling when run_until_exception raises an error."""
        mock_clear_event_loop = mocker.patch(
            "tsercom.runtime.runtime_main.clear_tsercom_event_loop"
        )
        MockThreadWatcher = mocker.patch(
            "tsercom.runtime.runtime_main.ThreadWatcher",
            return_value=mocker.Mock(spec=ThreadWatcher),
        )
        mock_create_event_loop = mocker.patch(
            "tsercom.runtime.runtime_main.create_tsercom_event_loop_from_watcher"
        )
        MockSplitProcessErrorWatcherSink = mocker.patch(
            "tsercom.runtime.runtime_main.SplitProcessErrorWatcherSink"
        )
        mock_initialize_runtimes = mocker.patch(
            "tsercom.runtime.runtime_main.initialize_runtimes"
        )
        mock_run_on_event_loop = mocker.patch(
            "tsercom.runtime.runtime_main.run_on_event_loop"
        )

        mock_factories = [mocker.Mock(spec=RuntimeFactory)]
        mock_error_queue = mocker.Mock(spec=MultiprocessQueueSink)

        mock_runtime1 = mocker.Mock(spec=Runtime)
        mock_runtime1.stop = mocker.Mock(name="runtime1_stop")
        mock_runtime2 = mocker.Mock(spec=Runtime)
        mock_runtime2.stop = mocker.Mock(name="runtime2_stop")
        mock_initialize_runtimes.return_value = [mock_runtime1, mock_runtime2]

        mock_sink_instance = MockSplitProcessErrorWatcherSink.return_value
        test_exception = RuntimeError("Test error from sink")
        mock_sink_instance.run_until_exception.side_effect = test_exception

        with pytest.raises(RuntimeError, match="Test error from sink"):
            remote_process_main(mock_factories, mock_error_queue)

        mock_error_queue.put_nowait.assert_called_once_with(test_exception)
>       assert mock_run_on_event_loop.call_count == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <MagicMock name='run_on_event_loop' id='139679100843824'>.call_count

tsercom/runtime/runtime_main_unittest.py:528: AssertionError
=============================== warnings summary ===============================
tsercom/threading/aio/global_event_loop_unittest.py::TestGlobalEventLoop::test_set_tsercom_event_loop_to_current_thread_no_running_loop
  /usr/lib/python3.10/asyncio/base_events.py:674: RuntimeWarning: coroutine 'RuntimeDataHandlerBase.__dispatch_poller_data_loop' was never awaited
    self._ready.clear()
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_initialization_with_no_arguments
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_in_process
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_out_of_process
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_out_of_process_is_testing_daemon
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_run_until_exception_error_watcher_none
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_check_for_exception_error_watcher_none
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_runtime_future_populator_indirectly
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_out_of_process_process_creation_fails
FAILED tsercom/runtime/runtime_config_unittest.py::TestRuntimeConfig::test_invalid_service_type_string
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseRegisterCaller::test_register_caller_mutex_args_none
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseRegisterCaller::test_register_caller_endpoint_without_port
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseRegisterCaller::test_register_caller_port_without_endpoint
FAILED tsercom/runtime/runtime_main_unittest.py::TestRemoteProcessMain::test_normal_execution
FAILED tsercom/runtime/runtime_main_unittest.py::TestRemoteProcessMain::test_exception_in_run_until_exception
======= 14 failed, 504 passed, 1 skipped, 1 warning in 76.83s (0:01:16) ========

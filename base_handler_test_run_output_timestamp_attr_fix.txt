============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-8.3.5, pluggy-1.5.0
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, timeout-2.4.0, mock-3.14.1, anyio-4.9.0, cov-6.1.1, json-report-1.5.0, metadata-3.1.1
asyncio: mode=strict, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
timeout: 60.0s
timeout method: signal
timeout func_only: False
collected 21 items

tsercom/runtime/runtime_data_handler_base_unittest.py .......FF.F....... [ 85%]
...                                                                      [100%]

=================================== FAILURES ===================================
_______ TestRuntimeDataHandlerBaseBehavior.test_processor_desynchronize ________

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f9812a61f00>
data_processor = <tsercom.runtime.runtime_data_handler_base.RuntimeDataHandlerBase._DataProcessorImpl object at 0x7f9812863160>
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='140291122525280'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f981282d6f0>

    @pytest.mark.asyncio
    async def test_processor_desynchronize(
        self, data_processor, mock_sync_clock, mocker
    ):
        mock_server_ts = mocker.MagicMock(spec=ServerTimestamp)
        mock_server_ts.timestamp = (
            mocker.MagicMock()
        )  # Add .timestamp attribute
        expected_datetime = datetime.datetime.now(datetime.timezone.utc)
        mock_sync_clock.desync.return_value = expected_datetime

>       result_dt = await data_processor.desynchronize(mock_server_ts)

tsercom/runtime/runtime_data_handler_base_unittest.py:362:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tsercom/runtime/runtime_data_handler_base.py:359: in desynchronize
    st = SynchronizedTimestamp.try_parse(timestamp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'tsercom.timesync.common.synchronized_timestamp.SynchronizedTimestamp'>
other = <MagicMock name='mock.timestamp' id='140291122576544'>

    @classmethod
    def try_parse(
        cls, other: Timestamp | ServerTimestamp
    ) -> Optional["SynchronizedTimestamp"]:
        """Tries to parse 'other' into a SynchronizedTimestamp."""
        if other is None:
            return None

        if isinstance(other, ServerTimestamp):
            other = other.timestamp

        # This assertion is a useful precondition check.
        if not isinstance(other, Timestamp):
>           raise TypeError(
                "Input must be a gRPC Timestamp or resolve to one."
            )
E           TypeError: Input must be a gRPC Timestamp or resolve to one.

tsercom/timesync/common/synchronized_timestamp.py:55: TypeError
_____ TestRuntimeDataHandlerBaseBehavior.test_processor_deregister_caller ______

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f9812a63670>
data_processor = <tsercom.runtime.runtime_data_handler_base.RuntimeDataHandlerBase._DataProcessorImpl object at 0x7f98128629e0>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f9812872a40>
test_caller_id_instance = CallerIdentifier('efdcc247-52cb-4911-8793-2fbce2045bf4')

    @pytest.mark.asyncio
    async def test_processor_deregister_caller(
        self, data_processor, handler, test_caller_id_instance
    ):
>       await data_processor.deregister_caller()

tsercom/runtime/runtime_data_handler_base_unittest.py:371:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.runtime.runtime_data_handler_base.RuntimeDataHandlerBase._DataProcessorImpl object at 0x7f98128629e0>

    async def deregister_caller(self) -> None:
        """Deregisters caller via the parent data handler."""
        # Return value of _unregister_caller (bool) is ignored
        # to match supertype's None return.
        # pylint: disable=protected-access # Outer class call
>       await self.__data_handler._unregister_caller(self.caller_id)
E       TypeError: object bool can't be used in 'await' expression

tsercom/runtime/runtime_data_handler_base.py:369: TypeError
_ TestRuntimeDataHandlerBaseBehavior.test_processor_process_data_with_server_timestamp _

self = <tsercom.runtime.runtime_data_handler_base_unittest.TestRuntimeDataHandlerBaseBehavior object at 0x7f9812a63dc0>
data_processor = <tsercom.runtime.runtime_data_handler_base.RuntimeDataHandlerBase._DataProcessorImpl object at 0x7f9812734df0>
handler = <tsercom.runtime.runtime_data_handler_base_unittest.TestableRuntimeDataHandler object at 0x7f981291b9a0>
test_caller_id_instance = CallerIdentifier('440c9de3-5d39-49c0-9d9b-724d531f5e13')
mock_sync_clock = <MagicMock spec='SynchronizedClock' id='140291121890784'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f98128c7ac0>

    @pytest.mark.asyncio
    async def test_processor_process_data_with_server_timestamp(
        self,
        data_processor,
        handler,
        test_caller_id_instance,
        mock_sync_clock,
        mocker,
    ):
        test_payload = "payload_with_server_ts"
        mock_server_ts = mocker.MagicMock(spec=ServerTimestamp)
        mock_server_ts.timestamp = (
            mocker.MagicMock()
        )  # Add .timestamp attribute
        expected_desynced_dt = datetime.datetime.now(
            datetime.timezone.utc
        ) - datetime.timedelta(seconds=5)

        # Mock the desynchronize method of the specific processor instance
        # Or, rely on mock_sync_clock.desync which is used by processor.desynchronize
        mock_sync_clock.desync.return_value = expected_desynced_dt

>       await data_processor.process_data(test_payload, mock_server_ts)

tsercom/runtime/runtime_data_handler_base_unittest.py:417:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tsercom/runtime/endpoint_data_processor.py:122: in process_data
    maybe_timestamp = await self.desynchronize(timestamp)
tsercom/runtime/runtime_data_handler_base.py:359: in desynchronize
    st = SynchronizedTimestamp.try_parse(timestamp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'tsercom.timesync.common.synchronized_timestamp.SynchronizedTimestamp'>
other = <MagicMock name='mock.timestamp' id='140291121898848'>

    @classmethod
    def try_parse(
        cls, other: Timestamp | ServerTimestamp
    ) -> Optional["SynchronizedTimestamp"]:
        """Tries to parse 'other' into a SynchronizedTimestamp."""
        if other is None:
            return None

        if isinstance(other, ServerTimestamp):
            other = other.timestamp

        # This assertion is a useful precondition check.
        if not isinstance(other, Timestamp):
>           raise TypeError(
                "Input must be a gRPC Timestamp or resolve to one."
            )
E           TypeError: Input must be a gRPC Timestamp or resolve to one.

tsercom/timesync/common/synchronized_timestamp.py:55: TypeError
=========================== short test summary info ============================
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_desynchronize
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_deregister_caller
FAILED tsercom/runtime/runtime_data_handler_base_unittest.py::TestRuntimeDataHandlerBaseBehavior::test_processor_process_data_with_server_timestamp
========================= 3 failed, 18 passed in 0.63s =========================

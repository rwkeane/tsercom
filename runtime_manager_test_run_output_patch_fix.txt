============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-8.3.5, pluggy-1.5.0
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, timeout-2.4.0, mock-3.14.1, anyio-4.9.0, cov-6.1.1, json-report-1.5.0, metadata-3.1.1
asyncio: mode=strict, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
timeout: 60.0s
timeout method: signal
timeout func_only: False
collected 17 items

tsercom/api/runtime_manager_unittest.py F.......F.F..F..F                [100%]

=================================== FAILURES ===================================
___________ TestRuntimeManager.test_initialization_with_no_arguments ___________

self = <MagicMock name='LFF_ConstructorProxy' id='139678855621520'>
args = (<MagicMock name='ThreadWatcher().create_tracked_thread_pool_executor()' id='139678854035104'>,)
kwargs = {}
msg = "Expected 'LFF_ConstructorProxy' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'LFF_ConstructorProxy' to be called once. Called 0 times.

/usr/lib/python3.10/unittest/mock.py:940: AssertionError

During handling of the above exception, another exception occurred:

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f09846f14e0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09847b5c30>

    def test_initialization_with_no_arguments(self, mocker):
        """Test RuntimeManager() with no arguments: Ensure internal dependencies are created."""
        mock_tw = mocker.patch(
            "tsercom.api.runtime_manager.ThreadWatcher", autospec=True
        )
        mock_lff_class = mocker.patch(
            "tsercom.api.runtime_manager.LocalRuntimeFactoryFactory"
        )
        mock_lff_constructor_callable = mocker.MagicMock(
            name="LFF_ConstructorProxy"
        )
        mock_lff_class.__getitem__.return_value = mock_lff_constructor_callable
        mock_sff_class = mocker.patch(
            "tsercom.api.runtime_manager.SplitRuntimeFactoryFactory"
        )
        mock_sff_constructor_callable = mocker.MagicMock(
            name="SFF_ConstructorProxy"
        )
        mock_sff_class.__getitem__.return_value = mock_sff_constructor_callable
        mock_pc_constructor = mocker.patch(
            "tsercom.api.runtime_manager.ProcessCreator", autospec=True
        )
        mock_sewsf_constructor = mocker.patch(
            "tsercom.api.runtime_manager.SplitErrorWatcherSourceFactory",
            autospec=True,
        )
        mock_thread_watcher_instance = mock_tw.return_value
        mock_thread_pool = mocker.MagicMock()
        mock_thread_watcher_instance.create_tracked_thread_pool_executor.return_value = (
            mock_thread_pool
        )

        manager = RuntimeManager(is_testing=True)

        mock_tw.assert_called_once()
>       mock_lff_constructor_callable.assert_called_once_with(mock_thread_pool)
E       AssertionError: Expected 'LFF_ConstructorProxy' to be called once. Called 0 times.

tsercom/api/runtime_manager_unittest.py:137: AssertionError
________ TestRuntimeManager.test_start_out_of_process_is_testing_daemon ________

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f09846f20e0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f098480b2b0>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09847b8040>

    def test_start_out_of_process_is_testing_daemon(
        self, mocker, manager_with_mocks
    ):
        manager_with_mocks._RuntimeManager__is_testing = True
        mocker.patch(
            "tsercom.api.runtime_manager.create_tsercom_event_loop_from_watcher"
        )
        mocker.patch(
            "tsercom.api.runtime_manager.create_multiprocess_queues",
            return_value=(MagicMock(), MagicMock()),
        )
>       mocker.patch("tsercom.api.runtime_manager.remote_process_main")

tsercom/api/runtime_manager_unittest.py:416:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:439: in __call__
    return self._start_patch(
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:257: in _start_patch
    mocked: MockType = p.start()
/usr/lib/python3.10/unittest/mock.py:1595: in start
    result = self.__enter__()
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f0984798250>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'remote_process_main'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
________ TestRuntimeManager.test_run_until_exception_error_watcher_none ________

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f09846f2ec0>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09847f3670>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f0984738670>

    def test_run_until_exception_error_watcher_none(
        self, manager_with_mocks, mocker
    ):
        mocker.patch.object(
            RuntimeManager,
            "has_started",
            new_callable=PropertyMock,
            return_value=True,
        )
        manager_with_mocks._RuntimeManager__thread_watcher = None
        with pytest.raises(
            RuntimeError,
            match="Error watcher is not available. Ensure the RuntimeManager has been properly started.",
        ):
>           manager_with_mocks.run_until_exception()

tsercom/api/runtime_manager_unittest.py:445:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09847f3670>

    def run_until_exception(self) -> None:
        """Blocks the calling thread until an exception is reported from any managed runtime.

        This method relies on the internal `ThreadWatcher` (for in-process runtimes)
        or the `SplitProcessErrorWatcherSource` (for out-of-process runtimes via
        the `ThreadWatcher`) to signal an exception. When an exception is caught,
        this method re-raises it in the calling thread.

        Raises:
            Exception: The first exception propagated from any managed runtime.
            RuntimeError: If the manager has not been started or if the
                necessary error watching components are not available.
        """
        if not self.has_started:
            raise RuntimeError("RuntimeManager has not been started.")
        # The __thread_watcher is initialized in __init__, so it should always be present.
>       self.__thread_watcher.run_until_exception()
E       AttributeError: 'NoneType' object has no attribute 'run_until_exception'

tsercom/api/runtime_manager.py:373: AttributeError
________ TestRuntimeManager.test_check_for_exception_error_watcher_none ________

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f09847b67d0>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f0984501630>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f09847d1450>

    def test_check_for_exception_error_watcher_none(
        self, manager_with_mocks, mocker
    ):
        mocker.patch.object(
            RuntimeManager,
            "has_started",
            new_callable=PropertyMock,
            return_value=True,
        )
        manager_with_mocks._RuntimeManager__thread_watcher = None
        with pytest.raises(
            RuntimeError,
            match="Error watcher is not available. Ensure the RuntimeManager has been properly started.",
        ):
>           manager_with_mocks.check_for_exception()

tsercom/api/runtime_manager_unittest.py:482:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f0984501630>

    def check_for_exception(self) -> None:
        """Checks for and re-raises the first caught exception from managed runtimes.

        If an exception has been propagated from any runtime and caught by the
        manager\'s error watching mechanisms, this method re-raises that
        exception in the calling thread. If no exceptions have been caught,
        this method does nothing. This method is thread-safe.

        Raises:
            Exception: The first exception propagated from any managed runtime, if any.
            RuntimeError: If the manager has been started but the internal
                `ThreadWatcher` is somehow not available (should not happen
                with proper initialization).
        """
        if not self.has_started:
            return
        # The __thread_watcher is initialized in __init__.
>       self.__thread_watcher.check_for_exception()
E       AttributeError: 'NoneType' object has no attribute 'check_for_exception'

tsercom/api/runtime_manager.py:392: AttributeError
_____ TestRuntimeManager.test_start_out_of_process_process_creation_fails ______

self = <tsercom.api.runtime_manager_unittest.TestRuntimeManager object at 0x7f09847b5f00>
manager_with_mocks = <tsercom.api.runtime_manager.RuntimeManager object at 0x7f09844f5a20>
mock_process_creator = <MagicMock spec='ProcessCreator' id='139678851241520'>
mocker = <pytest_mock.plugin.MockerFixture object at 0x7f0984453e20>

    def test_start_out_of_process_process_creation_fails(
        self, manager_with_mocks, mock_process_creator, mocker
    ):
        mock_process_creator.create_process.return_value = None
        mocker.patch(
            "tsercom.api.runtime_manager.create_tsercom_event_loop_from_watcher"
        )
        mocker.patch(
            "tsercom.api.runtime_manager.create_multiprocess_queues",
            return_value=(MagicMock(), MagicMock()),
        )
>       mocker.patch("tsercom.api.runtime_manager.remote_process_main")

tsercom/api/runtime_manager_unittest.py:564:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:439: in __call__
    return self._start_patch(
/home/swebot/.local/lib/python3.10/site-packages/pytest_mock/plugin.py:257: in _start_patch
    mocked: MockType = p.start()
/usr/lib/python3.10/unittest/mock.py:1595: in start
    result = self.__enter__()
/usr/lib/python3.10/unittest/mock.py:1447: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f09844d9060>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tsercom.api.runtime_manager' from '/app/tsercom/api/runtime_manager.py'> does not have the attribute 'remote_process_main'

/usr/lib/python3.10/unittest/mock.py:1420: AttributeError
=============================== warnings summary ===============================
tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_out_of_process
  /usr/lib/python3.10/unittest/mock.py:2135: RuntimeWarning: coroutine 'dummy_coroutine_for_test' was never awaited
    setattr(_type, entry, MagicProxy(entry, self))
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_initialization_with_no_arguments
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_out_of_process_is_testing_daemon
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_run_until_exception_error_watcher_none
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_check_for_exception_error_watcher_none
FAILED tsercom/api/runtime_manager_unittest.py::TestRuntimeManager::test_start_out_of_process_process_creation_fails
=================== 5 failed, 12 passed, 1 warning in 0.76s ====================
